<html>
<head>
  <title>day03-tcp转换图,多路io转接</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="2467"/>
<h1>day03-tcp转换图,多路io转接</h1>

<div>
<span><div>1 tcp状态转换图</div><div><img src="day03-tcp转换图,多路io转接_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>2 MSL</div><div>报文最大生存时间</div><div>  在linux下,2MSL大概是30S</div><div><br/></div><div><br/></div><div>3 为什么主动方调用close关闭,在最后一次挥手.发送完ACK之后还要等2MSL时间</div><div>因为我们网络中的数据包有可能丢失,假设发生最后一次ACK时,这个ACK 丢失,被动方没有收到ACK,就会等待一会之后在重发FIN,这个时候主动方就可以再次回ACK</div><div><br/></div><div><br/></div><div>4 半关闭:</div><div>半关闭:  主动方发送FIN请求,收到ACK.这个时候处于半关闭状态;</div><div>半关闭的特点: 主动方这个时候应用层还可以收数据,不可以发数据</div><div><br/></div><div><img src="day03-tcp转换图,多路io转接_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;"><font style="font-size: 12pt;">#include &lt;sys/socket.h&gt;</font></span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;"><font style="font-size: 12pt;">int shutdown(int sockfd, int how);</font></span></div><div style="margin-top: 1em; margin-bottom: 1em;"><font style="font-size: 12pt;"><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">sockfd:</span> <span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">需要关闭的</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">socket</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">的描述符</span></font></div><div style="margin-top: 1em; margin-bottom: 1em;"><font style="font-size: 12pt;"><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">how:</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">   </span> <span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">允许为</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">shutdown</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">操作选择以下几种方式</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">:</span></font></div><div style="margin-top: 1em; margin-bottom: 1em;"><font style="font-size: 12pt;"><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">   </span> <span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">SHUT_RD(0)</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">：</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">   </span> <span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">关闭</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">sockfd</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">上的读功能，此选项将不允许</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">sockfd</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">进行读操作。</span></font></div><div style="margin-top: 1em; margin-bottom: 1em;"><font style="font-size: 12pt;"><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">                  </span> <span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">该套接字</span><span style="font-family: 宋体; font-weight: bold; color: rgb(51, 51, 51);-en-paragraph:true;">不再接收数据</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span></font></div><div style="margin-top: 1em; margin-bottom: 1em;"><font style="font-size: 12pt;"><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">   </span> <span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">SHUT_WR(1):</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">    </span> <span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">关闭</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">sockfd</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">的写功能，此选项将不允许</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">sockfd</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">进行写操作。进程不能在对此套接字发出写操作。</span></font></div><div><font style="font-size: 12pt;"><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">   </span> <span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">SHUT_RDWR(2):</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">  </span> <span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">关闭</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">sockfd</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">的读写功能。相当于调用</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">shutdown</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">两次：首先是以</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">SHUT_RD,</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">然后以</span><span style="font-family: Monaco; color: rgb(51, 51, 51);-en-paragraph:true;">SHUT_WR</span><span style="font-family: 宋体; color: rgb(51, 51, 51);-en-paragraph:true;">。</span></font></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51); font-size: 12pt;">shutdown(fd,<span style="font-size: 12pt; font-family: Monaco; color: rgb(51, 51, 51);">SHUT_RDWR</span> );//不涉及文件描述符的计数</span></div><div><br/></div><div><br/></div><div>5 端口复用  </div><div>端口重新(重复)使用</div><div>注意:如果一个系统中有多个相同的端口程序,只有一个程序的端口起作用,一般这个程序是最后使用了那个端口的程序</div><div><br/></div><div>设置端口复用</div><div>socklen_t len = 1;</div><div>int setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;len, sizeof(socklen_t));</div><div><br/></div><div>6 心跳包</div><div> 设置tcp选项 心跳</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);-en-paragraph:true;">keepAlive = 1;</span></div><div><span style="mso-tab-count: 1; font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);-en-paragraph:true;">   </span> <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);-en-paragraph:true;">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));</span></div></div><div><br/></div><div>一般不使用这个: 一般人为自己去写.注意,心跳包,一定是最小粒度</div><div>乒乓包:  和心跳包基本一样,只是携带的数据比较多</div><div><br/></div><div><br/></div><div>7 高并发服务器</div><div><br/></div><div>方式1:  阻塞等待  - 浪费资源</div><div>方式2: 非阻塞忙轮询  - 耗cpu</div><div><br/></div><div>以上的2种方式都不完美,有缺点</div><div>方式3: 多路io转接技术(多路io复用)</div><div><br/></div><div>对路io转接技术有3中方法可以实现</div><div>select</div><div>poll</div><div>epoll</div><div><br/></div><div><br/></div><div>8 文件描述符</div><div>内核中会有一张表,这张的数据结构是位图,位图中的某一位置1,代表这个这一位的下标(文件描述符)指向了打开的那个文件</div><div><img src="day03-tcp转换图,多路io转接_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>8 select  函数</div><div>#include &lt;sys/select.h&gt;</div><div>int select(int nfds, fd_set *readfds, fd_set *writefds,</div><div>                  fd_set *exceptfds, struct timeval *timeout);</div><div><br/></div><div>       void FD_CLR(int fd, fd_set *set);//将文件描述符fd从集合set中删除</div><div>       int  FD_ISSET(int fd, fd_set *set);//判断文件描述符是否在set集合中</div><div>       void FD_SET(int fd, fd_set *set);//将文件描述符fd添加到set集合中</div><div>       void FD_ZERO(fd_set *set);//清空文件描述符集合</div><div><br/></div><div>功能: 监听文件描述符的属性(可读,可写,异常)变化</div><div>参数: nfds   监听的最大文件描述符加1</div><div>fd_set *readfds:监听读属性变化的文件描述符集合(将需要监听读属性变化的文件描述符添加至readfds 集合)</div><div>fd_set *writefds,:监听写属性变化的文件描述符集合(将需要监听写属性变化的文件描述符添加至writefds 集合)</div><div>fd_set *exceptfds ,:监听异常属性变化的文件描述符集合(将需要监听异常属性变化的文件描述符添加至writefds 集合)</div><div><br/></div><div>struct timeval *timeout: 监听的时长</div><div>struct timeval {</div><div>               long    tv_sec;         /* seconds */</div><div>               long    tv_usec;        /* microseconds */</div><div>           };</div><div><br/></div><div>struct timeval t;</div><div>t.tv_sec =1;</div><div>t.tv_usec =0;</div><div>如果写固定的值,那么就监听固定的时间</div><div>如果写NULL,永久等待(一般填这个)<br/>
如果写0,代表不等待</div><div><br/>
返回值:  监听到文件描述符变化的个数</div><div><img src="day03-tcp转换图,多路io转接_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>9 select 的优缺点</div><div>优点:</div><div>并发量大</div><div>跨平台 windows  linux ....都支持</div><div><br/></div><div>缺点</div><div>1 编写代码困难</div><div>2  select返回变化的文件描述符,需要人为遍历一遍</div><div>3  每次都要给一份监听的集合给到select,这个集合要从应用层拷贝带内存.每次这样拷贝,消耗资源</div><div><br/></div><div><br/></div><div>1  如果4-1023文件描述符需要监听,但是.5-1000这些文件描述符都关闭了,怎么解决</div><div>2  如果4-1023文件描述符需要监听 ,只有5,6,8有变化,怎解决?</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 